# -*- coding: utf-8 -*-
"""streamlit-app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/197CkMrwMiEbRO0YGglnfWZGwEkiNNHZG
"""

# app.py

import streamlit as st
import pandas as pd
import numpy as np
import os
from langchain.embeddings import HuggingFaceEmbeddings
from langchain.vectorstores import Chroma
from langchain_community.document_loaders import TextLoader
from langchain_text_splitters import CharacterTextSplitter

# ----------------------------
# CONFIG & PAGE SETTINGS
# ----------------------------
st.set_page_config(page_title="ðŸ“š AI-Powered Book Discovery", layout="wide")
st.title("ðŸ“š AI-Powered Book Discovery Platform")
st.write("Find books based on semantic meaning and emotional tone.")

# ----------------------------
# LOAD DATA
# ----------------------------
@st.cache_data
def load_books():
    books = pd.read_csv("books_with_emotions.csv")
    books["large_thumbnail"] = books["thumbnail"].fillna("") + "&fife=w800"
    books["large_thumbnail"] = np.where(
        books["large_thumbnail"].isna(),
        "cover-not-found.jpg",
        books["large_thumbnail"]
    )
    return books

books = load_books()

# ----------------------------
# LOAD / CREATE CHROMA VECTOR DB
# ----------------------------
@st.cache_resource
def load_chroma():
    embedding_model = HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")

    # If vector store doesn't exist, rebuild from descriptions
    if not os.path.exists("chroma_db_books"):
        st.warning("Vector database not found. Creating it now (may take a few minutes)...")

        # Prepare documents from tagged descriptions
        books["tagged_description"] = books["isbn13"].astype(str) + " " + books["description"].fillna("")
        books["tagged_description"].to_csv("tagged_description.txt", sep="\n", index=False, header=False)

        loader = TextLoader("tagged_description.txt", encoding="utf-8")
        raw_docs = loader.load()
        splitter = CharacterTextSplitter(chunk_size=0, chunk_overlap=0, separator="\n")
        documents = splitter.split_documents(raw_docs)

        db = Chroma.from_documents(documents, embedding=embedding_model, persist_directory="chroma_db_books")
        db.persist()
        return db
    else:
        return Chroma(
            collection_name="book_collection",
            embedding_function=embedding_model,
            persist_directory="chroma_db_books"
        )

db_books = load_chroma()

# ----------------------------
# SEMANTIC SEARCH LOGIC
# ----------------------------
def retrieve_semantic_recommendations(query, category=None, tone=None, initial_top_k=50, final_top_k=16):
    recs = db_books.similarity_search(query, k=initial_top_k)
    books_list = [int(rec.page_content.strip('"').split()[0]) for rec in recs]
    book_recs = books[books["isbn13"].isin(books_list)].head(initial_top_k)

    if category != "All":
        book_recs = book_recs[book_recs["simple_categories"] == category].head(final_top_k)
    else:
        book_recs = book_recs.head(final_top_k)

    if tone == "Happy":
        book_recs = book_recs.sort_values(by="joy", ascending=False)
    elif tone == "Surprising":
        book_recs = book_recs.sort_values(by="surprise", ascending=False)
    elif tone == "Angry":
        book_recs = book_recs.sort_values(by="anger", ascending=False)
    elif tone == "Suspenseful":
        book_recs = book_recs.sort_values(by="fear", ascending=False)
    elif tone == "Sad":
        book_recs = book_recs.sort_values(by="sadness", ascending=False)

    return book_recs

# ----------------------------
# UI INTERFACE
# ----------------------------
query = st.text_input("Enter a book description (e.g., A story about courage and survival):")
categories = ["All"] + sorted(books["simple_categories"].dropna().unique())
tones = ["All", "Happy", "Surprising", "Angry", "Suspenseful", "Sad"]

col1, col2 = st.columns(2)
with col1:
    category = st.selectbox("Filter by category:", categories)
with col2:
    tone = st.selectbox("Filter by emotional tone:", tones)

if st.button("ðŸ” Find Recommendations"):
    if not query.strip():
        st.error("Please enter a book description to search.")
    else:
        with st.spinner("ðŸ”Ž Searching for books..."):
            recommendations = retrieve_semantic_recommendations(query, category, tone)

        if recommendations.empty:
            st.warning("No recommendations found.")
        else:
            for _, row in recommendations.iterrows():
                col1, col2 = st.columns([1, 4])
                with col1:
                    st.image(row["large_thumbnail"], use_column_width=True)
                with col2:
                    authors_split = row["authors"].split(";")
                    if len(authors_split) == 2:
                        authors_str = f"{authors_split[0]} and {authors_split[1]}"
                    elif len(authors_split) > 2:
                        authors_str = f"{', '.join(authors_split[:-1])}, and {authors_split[-1]}"
                    else:
                        authors_str = row["authors"]

                    st.markdown(f"### {row['title']}")
                    st.markdown(f"**Author(s):** {authors_str}")
                    st.markdown(f"**Rating:** {row['average_rating']}")
                    st.markdown(row["description"])