# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/197CkMrwMiEbRO0YGglnfWZGwEkiNNHZG
"""

# app.py

import streamlit as st
import pandas as pd
import numpy as np
from langchain.embeddings import HuggingFaceEmbeddings
from langchain.vectorstores import Chroma

# Load book metadata
books = pd.read_csv("books_with_emotions.csv")
books["large_thumbnail"] = books["thumbnail"] + "&fife=w800"
books["large_thumbnail"] = np.where(
    books["large_thumbnail"].isna(),
    "cover-not-found.jpg",
    books["large_thumbnail"],
)

# Load Chroma vector DB
embedding_model = HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")
db_books = Chroma(
    collection_name="book_collection",
    embedding_function=embedding_model,
    persist_directory="chroma_db_books"
)

# Recommendation logic
def retrieve_semantic_recommendations(query, category=None, tone=None, initial_top_k=50, final_top_k=16):
    recs = db_books.similarity_search(query, k=initial_top_k)
    books_list = [int(rec.page_content.strip('"').split()[0]) for rec in recs]
    book_recs = books[books["isbn13"].isin(books_list)].head(initial_top_k)

    if category != "All":
        book_recs = book_recs[book_recs["simple_categories"] == category].head(final_top_k)
    else:
        book_recs = book_recs.head(final_top_k)

    if tone == "Happy":
        book_recs = book_recs.sort_values(by="joy", ascending=False)
    elif tone == "Surprising":
        book_recs = book_recs.sort_values(by="surprise", ascending=False)
    elif tone == "Angry":
        book_recs = book_recs.sort_values(by="anger", ascending=False)
    elif tone == "Suspenseful":
        book_recs = book_recs.sort_values(by="fear", ascending=False)
    elif tone == "Sad":
        book_recs = book_recs.sort_values(by="sadness", ascending=False)

    return book_recs

# Streamlit UI
st.set_page_config(page_title="ðŸ“š Semantic Book Recommender", layout="wide")
st.title("ðŸ“š Semantic Book Recommender")
st.write("Find books based on meaning and emotional tone.")

query = st.text_input("Enter a book description (e.g., A story about courage and survival):")

categories = ["All"] + sorted(books["simple_categories"].dropna().unique())
tones = ["All", "Happy", "Surprising", "Angry", "Suspenseful", "Sad"]

category = st.selectbox("Filter by category:", categories)
tone = st.selectbox("Filter by emotional tone:", tones)

if st.button("Find recommendations"):
    with st.spinner("Finding books..."):
        recommendations = retrieve_semantic_recommendations(query, category, tone)

        for _, row in recommendations.iterrows():
            col1, col2 = st.columns([1, 4])
            with col1:
                st.image(row["large_thumbnail"], use_column_width=True)
            with col2:
                authors_split = row["authors"].split(";")
                if len(authors_split) == 2:
                    authors_str = f"{authors_split[0]} and {authors_split[1]}"
                elif len(authors_split) > 2:
                    authors_str = f"{', '.join(authors_split[:-1])}, and {authors_split[-1]}"
                else:
                    authors_str = row["authors"]

                st.markdown(f"### {row['title']}")
                st.markdown(f"**Author(s):** {authors_str}")
                st.markdown(f"**Rating:** {row['average_rating']}")
                st.markdown(row["description"])